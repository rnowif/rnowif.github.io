<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: refactoring | Renaud Humbert-Labeaumaz]]></title>
  <link href="https://rnowif.github.io/blog/categories/refactoring/atom.xml" rel="self"/>
  <link href="https://rnowif.github.io/"/>
  <updated>2018-10-21T00:12:26+13:00</updated>
  <id>https://rnowif.github.io/</id>
  <author>
    <name><![CDATA[Renaud Humbert-Labeaumaz]]></name>
    <email><![CDATA[rnow.if@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Trivia Kata: A Refactoring Story]]></title>
    <link href="https://rnowif.github.io/blog/2017/04/10/trivia-refactoring/"/>
    <updated>2017-04-10T18:52:15+12:00</updated>
    <id>https://rnowif.github.io/blog/2017/04/10/trivia-refactoring</id>
    <content type="html"><![CDATA[<p>Refactoring a legacy code can be a tricky business. More often than not, the code is not tested, unclear and contains some bugs. If not planned, the time required to refactor will eat all the time allocated to the feature. The feature will then be implemented very quickly and it will result in more buggy unmaintainable code.</p>

<p>In this blog post, I will try to show some tools and methods to refactor safely a piece of code. I will use the <a href="https://github.com/jbrains/trivia">trivia kata</a> as a support for this. The resulting code can be found on <a href="https://github.com/rnowif/trivia-refactoring/commits/master">GitHub</a>.</p>

<!-- more -->


<h2>Characterization Test: the Golden Master</h2>

<p>The prerequisite to any refactor is to build a test harness to be sure that the refactoring will not break anything. In this example, it could seem like a waste of time to test all possible paths with unit tests. Fortunately, the code contains a lot of traces that print what the code does. It is then possible to run the code with a set of inputs, capture the output and save it. This output is called the <em>Golden Master</em>. Every time the code is modified, the same inputs are used to run the code and the output is compared to the golden master. As you may have noticed, this will not ensure that the code is bug-free, it will just make sure that the code always <strong>behaves</strong> the same.</p>

<p>In Java, the golden master can be implemented using a library called <em>approval</em>:</p>

<pre><code class="java">&lt;dependency&gt;
    &lt;groupId&gt;com.github.nikolavp&lt;/groupId&gt;
    &lt;artifactId&gt;approval-core&lt;/artifactId&gt;
    &lt;version&gt;0.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>

<p>The associated test is shown below (see <a href="https://github.com/rnowif/trivia-refactoring/commit/0c4255e69cc5395a70de417913de20c82606b0c2">commit</a>):</p>

<pre><code class="java">@Test
public void should_record_and_verify_golden_master() {
    String result = playGame(1L);

    Approvals.verify(result, Paths.get("src", "main", "resources", "approval", "result.txt")); // 2
}

private String playGame(long seed) {
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    System.setOut(new PrintStream(outputStream)); // 3

    boolean notAWinner;
    Game aGame = new Game();

    aGame.add("Chet");
    aGame.add("Pat");
    aGame.add("Sue");

    Random rand = new Random(seed); // 1

    do {

        aGame.roll(rand.nextInt(5) + 1);

        if (rand.nextInt(9) == 7) {
            notAWinner = aGame.wrongAnswer();
        } else {
            notAWinner = aGame.wasCorrectlyAnswered();
        }

    } while (notAWinner);

    return new String(outputStream.toByteArray());
}
</code></pre>

<p>Since the code uses a <code>Random</code> to roll a dice, we have to fix the seed of the <code>Random</code> so it always returns the same random rolls in the same order (<code>1</code>). The code has to be run once with this seed and the output has to be pasted into <code>src/main/resources/approval/result.txt</code> to create the golden master (<code>2</code>). Afterwards, the test will capture the output (<code>3</code>) and compare it to the golden master. If a difference appears, a diff will prompt.</p>

<p>Sometimes during my refactoring sessions, I like to make mistakes on purpose just to check the robustness of my test harness. I find it very useful to increase the confidence you have in your tests and fix them if you have to.</p>

<h2>First Step: Clean Up</h2>

<p>Personnaly, I can&rsquo;t really think when I am in front of a bloated and unclear code. Thus, the first thing I did to refactor this piece of code is to rearrange it, delete unused imports and dead code, remove magic strings and magic numbers, use generics and reduce the visibility of fields and methods that can be reduced to be sure that I can touch them without breaking the public API. The major part of these refactorings can be made for you by your IDE so don&rsquo;t hesitate to do it as it reduces the risk of error and it is much quicker. You can also use a plugin like <a href="http://www.sonarlint.org/index.html">SonarLint</a> for instance to detect issues directly into your IDE.</p>

<p>Once the code easier to think about, I noticed that strings where used to identify categories. This seemed like a good place to create an enum (see <a href="https://github.com/rnowif/trivia-refactoring/commit/1578c0ce9d7da73641e5f4202b1a72f00ba13723">commit</a>). To start, I just replaced the strings with the enum:</p>

<pre><code class="java">private void askQuestion() {
    if (currentCategory() == "Pop")
        print(popQuestions.removeFirst());
    if (currentCategory() == "Science")
        print(scienceQuestions.removeFirst());
    if (currentCategory() == "Sports")
        print(sportsQuestions.removeFirst());
    if (currentCategory() == "Rock")
        print(rockQuestions.removeFirst());
}

private String currentCategory() {
    if (places[currentPlayer] == 0) return "Pop";
    if (places[currentPlayer] == 4) return "Pop";
    if (places[currentPlayer] == 8) return "Pop";
    if (places[currentPlayer] == 1) return "Science";
    if (places[currentPlayer] == 5) return "Science";
    if (places[currentPlayer] == 9) return "Science";
    if (places[currentPlayer] == 2) return "Sports";
    if (places[currentPlayer] == 6) return "Sports";
    if (places[currentPlayer] == 10) return "Sports";
    return "Rock";
}
</code></pre>

<p>became</p>

<pre><code class="java">private void askQuestion() {
    if (currentCategory().equals(Category.POP))
        print(popQuestions.removeFirst());
    if (currentCategory().equals(Category.SCIENCE))
        print(scienceQuestions.removeFirst());
    if (currentCategory().equals(Category.SPORTS))
        print(sportsQuestions.removeFirst());
    if (currentCategory().equals(Category.ROCK))
        print(rockQuestions.removeFirst());
}

private Category currentCategory() {
    if (places[currentPlayer] == 0) return Category.POP;
    if (places[currentPlayer] == 4) return Category.POP;
    if (places[currentPlayer] == 8) return Category.POP;
    if (places[currentPlayer] == 1) return Category.SCIENCE;
    if (places[currentPlayer] == 5) return Category.SCIENCE;
    if (places[currentPlayer] == 9) return Category.SCIENCE;
    if (places[currentPlayer] == 2) return Category.SPORTS;
    if (places[currentPlayer] == 6) return Category.SPORTS;
    if (places[currentPlayer] == 10) return Category.SPORTS;
    return Category.ROCK;
}
</code></pre>

<p>This kind of <code>if</code> statement that looks a lot like a <code>switch</code> can almost always be replaced by a <code>Map</code> so that is what I did (see <a href="https://github.com/rnowif/trivia-refactoring/commit/b8780743929eb10ab5f8a90c9fe68c9dd3c310a9">commit</a>). I created two maps to contain questions of each category and the category for each position:</p>

<pre><code class="java">private void askQuestion() {
    print(questionsByCategory.get(currentCategory()).removeFirst());
}

private Category currentCategory() {
   return categoriesByPosition.get(currentPosition());
}
</code></pre>

<h2>Second Step: Segregate</h2>

<p>The second step I chose to follow is to put specific logic into private methods. Once again, your IDE can help you here, use it!</p>

<p>For instance, that piece of code:</p>

<pre><code class="java">print(players.get(currentPlayer) + " is getting out of the penalty box");

places[currentPlayer] = places[currentPlayer] + roll;
if (places[currentPlayer] &gt;= NB_CELLS) {
    places[currentPlayer] = places[currentPlayer] - NB_CELLS;
}

print(players.get(currentPlayer)  + "'s new location is " + places[currentPlayer]);
</code></pre>

<p>became</p>

<pre><code class="java">print(players.get(currentPlayer) + " is getting out of the penalty box");
move(roll);
print(players.get(currentPlayer) + "'s new location is " + currentPosition());
</code></pre>

<p>By doing that, you can remove duplication by factorizing algorithms (like move a player) into specific methods. Moreover, you prepare the field for extracting objects from this code (see the next section). However, in order to do that properly, the private methods have to be in the purest form possible: they should use or modify the least amount of private fields possible (see <a href="https://github.com/rnowif/trivia-refactoring/commit/160c52d4a393fef3a58ad062fa9b552f0a9631a0">commit</a>). With that in mind, the following code:</p>

<pre><code class="java">private Category currentCategory() {
    return categoriesByPosition.get(currentPosition());
}
</code></pre>

<p>has been replaced by</p>

<pre><code class="java">private Category currentCategory(int position) {
    return categoriesByPosition.get(position);
}
</code></pre>

<h2>Third Step: Divide and Conquer</h2>

<p>Now that logic has been segregated into private methods, it is pretty straightforward to extract objects from these methods.</p>

<p>In this kata, we saw that several concepts emerge: <code>Player</code>, <code>Board</code> and <code>QuestionDeck</code>. A <code>PlayerList</code> class has also been added to handle the players rotation. All these classes can be tested in isolation in order not to rely solely on the golden master anymore.</p>

<p>For instance, the following code prints the next question to ask:</p>

<pre><code class="java">public void roll(int roll) {

  // ...

  Category currentCategory = board.categoryOf(newPosition);
  print("The category is " + currentCategory);
  print(nextQuestionAbout(currentCategory));
}

private String nextQuestionAbout(Category category) {
  return questionsByCategory.get(category).removeFirst();
}
</code></pre>

<p>By creating a <code>QuestionDeck</code> object, we can have a code like this (see <a href="https://github.com/rnowif/trivia-refactoring/commit/6ae3f22923b425d51f7fb657d7236926d2149309">commit</a>):</p>

<pre><code class="java">public void roll(int roll) {

  // QuestionDeck deck = new QuestionDeck(NB_QUESTIONS, CATEGORIES);

  Category currentCategory = board.categoryOf(newPosition);
  print("The category is " + currentCategory);
  print(deck.nextQuestionAbout(currentCategory));
}
</code></pre>

<p>The private method <code>nextQuestionAbout</code> and the field <code>questionsByCategory</code> are no longer in the <code>Game</code> class.</p>

<p>When you extract classes from the main code, it is very important not to break the public API. It is possible to annotate some methods with <code>@Deprecated</code> though (see <a href="https://github.com/rnowif/trivia-refactoring/commit/a7c4d85c50395a0a66908eb15e3926b6d8d822de">commit</a>). A good example of this can be seen in this <a href="https://www.crafties.fr/videos/2017-02-27-episode-9-refactoring-dependances-statiques.html">video</a>.</p>

<h2>Fourth Step: Break up</h2>

<p>The last step is when we remove all deprecated methods that we introduced during the refactoring. It is not always possible to do it right after the refactoring session as we don&rsquo;t always have access to the client code that consumes our public API. In this case we do, so I removed these methods (see <a href="https://github.com/rnowif/trivia-refactoring/commit/eb7ab019f62808b589de0f6a4fcf904163fd667d">commit</a>).</p>

<p>The client code looked like this:</p>

<pre><code class="java">Game aGame = new Game();

aGame.add("Chet");
aGame.add("Pat");
aGame.add("Sue");

// aGame.roll()
</code></pre>

<p>Now the <code>Game</code> class is not in charge of questions, board, categories and players anymore so we have to inject them into the constructor.</p>

<pre><code class="java">private static final int NB_CELLS = 12;
private static final int NB_QUESTIONS = 50;
private static final List&lt;Category&gt; CATEGORIES = asList(Category.POP, Category.SCIENCE, Category.SPORTS, Category.ROCK);
private static final List&lt;String&gt; PLAYERS = asList("Chet", "Pat", "Sue");

// ...
Game aGame = new Game(
        System.out,
        new Board(NB_CELLS, CATEGORIES),
        new QuestionDeck(NB_QUESTIONS, CATEGORIES),
        new PlayerList(PLAYERS)
);

// aGame.roll()
</code></pre>

<h2>Wrapping Up</h2>

<p>Of course, as it is always the case with refactoring, I could have done more. The main risk is that <em>more</em> does not always mean <em>better</em>. A refactoring session must have a purpose and it is very important to know when to stop. It could be when you can add your new feature or fix a bug seamlessly or simply because you don&rsquo;t have any more time allocated to this task.</p>

<p>I hope that this post gave you some tools and methods to refactor your code without the fear of breaking something.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Refactorer, c'est comme dormir]]></title>
    <link href="https://rnowif.github.io/blog/2016/02/01/refactorer-c-est-comme-dormir/"/>
    <updated>2016-02-01T07:16:09+13:00</updated>
    <id>https://rnowif.github.io/blog/2016/02/01/refactorer-c-est-comme-dormir</id>
    <content type="html"><![CDATA[<p>Robert est un développeur. On a demandé à Robert d'ajouter une nouvelle fonctionnalité à l'application. Robert aimerait bien en profiter pour refactorer un peu le code car il ne respecte pas les bonnes pratiques qu'il a pu voir lors du dernier meetup Software Craftsmanship. On dit alors à Robert qu'il ne peut pas refactorer car, en ce moment, il n'y a pas le temps pour ça et qu'il doit produire. Robert se dit qu'il n'y a de toutes façons jamais le temps&hellip;</p>

<p>Cette histoire vous semble familière ? En effet, le refactoring est souvent perçu comme n'apportant aucune valeur. D'autres choses dans la vie peuvent sembler n'apporter aucune valeur. Il y en a notamment une qui prend près du tiers de la vie d'une personne pendant laquelle cette personne ne fait littéralement rien : <em>dormir</em> !</p>

<!-- more -->


<p>Le nombre de choses que l'on pourrait faire si l'on ne dormait pas ! Cependant, au bout de quelques jours, voire quelques heures, des événements désagréables finiraient par survenir. Sans sommeil, la moindre des tâches peut devenir très longue à effectuer et des erreurs étranges peuvent arriver (comme verser du jus d'orange dans son bol de céréales). Après un certain temps, le sommeil prend le dessus de manière incontrôlée, ce qui peut conduire à des accidents (à cause d'une somnolence au volant par exemple).</p>

<p>De manière similaire, repousser le refactoring nuit au projet. Les développements peuvent prendre beaucoup plus de temps que nécessaire et des bugs peuvent survenir sur des fonctionnalités très éloignées de celles qui sont modifiées. De plus, il arrive un moment où le refactoring s'impose : le code ne peut plus être modifié sans risquer d'importantes régressions. Ceci peut se produire à un moment critique du projet et donc le mettre en péril. A ce moment là, la sentence tant redoutée peut tomber : « il faut tout réécrire ».</p>

<p>De manière globale, refactorer régulièrement est nécessaire à la bonne santé du projet, tout comme dormir chaque nuit l'est pour la notre. Dans la suite de cet article, nous allons définir ce que signifie refactorer dans ce contexte, quand est-il bon de le faire, comment bien le préparer et que faire si le temps manque.</p>

<h2>Que signifie refactorer ?</h2>

<p>Selon Michael Feathers, le refactoring est l'acte d'améliorer le <em>design</em> du code sans changer son comportement.</p>

<p>Il ne s'agit pas forcément de changer toute une hiérarchie de classes ou de mettre en place un <em>design pattern</em> très complexe mais cela peut être aussi simple que de renommer une variable, une méthode, une classe, d'extraire une méthode privée dans une classe externe, de regrouper les attributs d'une méthode dans un objet, etc.</p>

<p>De plus, nous considérons aussi qu'ajouter des tests à du code existant est du refactoring. En effet, un code testable est un premier pas vers un meilleur <em>design</em>.</p>

<h2>Quand faut-il refactorer ?</h2>

<p>L'idée n'est pas d'essayer de corriger l'intégralité du système à chaque fois. Ceci serait contre productif et impossible à mettre en place. De plus, il serait très difficilement justifiable de provoquer des régressions dans une partie du code très éloignée de celle qui est censée être modifiée.</p>

<p>Le refactoring est très efficace lorsqu'il est ciblé sur le code qui est concerné par le développement d'une fonctionnalité. De plus, il nous semble préférable de refactorer avant d'ajouter du nouveau code afin de démarrer sur des bases saines.</p>

<h2>Comment le préparer ?</h2>

<p>La première chose à faire avant de refactorer est de s'assurer qu'il y a des tests en place. Ces tests permettent de vérifier que le refactoring ne génère pas de régression. Si ces tests ne sont pas déjà en place, il faut les ajouter avant de commencer.</p>

<p>Il peut arriver qu'il soit impossible de tester une portion de code. Dans ce cas, il faut effectuer le refactoring minimum nécessaire à la mise en place des tests.</p>

<h2>Que faire si le temps manque ?</h2>

<p>Si, comme Robert, le temps vous manque, il faut faire preuve de pragmatisme. Il peut être intéressant d'effectuer de petits refactoing à chaque développement. Cela permet d'améliorer le <em>design</em> sans consommer trop de temps et de préparer le terrain pour de plus gros refactoring.</p>

<h2>Conclusion</h2>

<p>Le refactoring est essentiel dans un projet et doit être effectué régulièrement. Il permet d'assurer que les nouvelles fonctionnalités pourront être développées dans un temps raisonnable et de limiter les régressions en améliorant le <em>design</em>. Par ailleurs, il permet aussi aux développeurs de (re)prendre du plaisir à faire évoluer le produit.</p>

<p>Nous aimerions conclure avec la règle du boy scout qui indique que l'on doit toujours laisser le code dans un meilleur état que lorsqu'on l'a trouvé. L'application de cette règle conduit à l'amélioration de la qualité globale du code et à l'inversion de la dette technique.</p>

<hr />

<p><em>Cet article a été écrit en collaboration avec Nadia Humbert-Labeaumaz (<a href="https://www.twitter.com/nphumbert">@nphumbert</a>)</em></p>
]]></content>
  </entry>
  
</feed>
