<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c# | Renaud Humbert-Labeaumaz]]></title>
  <link href="https://rnowif.github.io/blog/categories/c-number/atom.xml" rel="self"/>
  <link href="https://rnowif.github.io/"/>
  <updated>2018-10-21T00:32:00+13:00</updated>
  <id>https://rnowif.github.io/</id>
  <author>
    <name><![CDATA[Renaud Humbert-Labeaumaz]]></name>
    <email><![CDATA[rnow.if@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C# for the Java Developer: Generics]]></title>
    <link href="https://rnowif.github.io/blog/2018/10/20/c-sharp-for-the-java-developer-generics/"/>
    <updated>2018-10-20T05:57:36+13:00</updated>
    <id>https://rnowif.github.io/blog/2018/10/20/c-sharp-for-the-java-developer-generics</id>
    <content type="html"><![CDATA[<p>In my journey into the C# world, I wanted to talk about generics. Generics exist in both Java and C# languages but their implementation is <em>very</em> different. This blog post aims to explain the differences and the similarities between the two.<br/>
TL;DR Java generics is a lie, C# generics is not.</p>

<!-- more -->


<h2>Java Generics is a Lie</h2>

<p>Generics have been introduced in Java 5. Before that, you had to manipulate <code>Objects</code> and cast them to the desired type:</p>

<pre><code class="java">List apples = new ArrayList();
apples.add(new Apple());
// This is really a list of objects, so the cast is required
Apple firstApple = (Apple) apples.get(0);
</code></pre>

<p>In the previous snippet, you should note that there is absolutely nothing that prevents you from adding a <code>Banana</code> into the list and make the program crash at runtime. Also, this code is still valid in the latest version of Java (which is Java 11 as we speak). To say the least, this approach is not very safe and do not leverage the type system as much as we could expect.</p>

<p>Since Java 5, it is then possible to use the generic version of the <code>List</code> class:</p>

<pre><code class="java">List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;();
apples.add(new Apple());
// The cast is not required any more thanks to the generics
Apple firstApple = apples.get(0);
</code></pre>

<p>The thing is that, at runtime, the two previous snippets are strictly equivalent. Indeed, Java generics are removed during compilation and the resulting bytecode only manipulate <code>Objects</code> and casts. This is called <em>type erasure</em>. As a consequence, it is not possible, in Java, to write code like this:</p>

<pre><code class="java">/**
 * Filter objects of the given type
 */
&lt;T&gt; List&lt;T&gt; filterObjectsOfType(List&lt;Object&gt; objects) {
    List&lt;T&gt; filteredObjects = new ArrayList&lt;&gt;();
    for (Object o : objects) {
        if (o instanceof T) {
            filteredObjects.add((T) o);
        }
    }
    return filteredObjects;
}
</code></pre>

<p>Indeed, the type of <code>T</code> is erased at runtime and the <code>instanceof</code> operation cannot be performed. That is why a class object is often passed as an argument of the method:</p>

<pre><code class="java">/**
 * Filter objects of the given type
 */
&lt;T&gt; List&lt;T&gt; filterObjectsOfType(List&lt;Object&gt; objects, Class&lt;T&gt; clazz) {
    List&lt;T&gt; filteredObjects = new ArrayList&lt;&gt;();
    for (Object o : objects) {
        if (clazz.isInstance(o)) {
            filteredObjects.add((T) o);
        }
    }
    return filteredObjects;
}
</code></pre>

<p>This method can be invoked like this:</p>

<pre><code class="java">List&lt;String&gt; stringsOnly = filterObjectsOfType(Arrays.asList("hello", 2), String.class);
// stringsOnly contains only "hello"
</code></pre>

<h2>C# Generics is a Runtime Feature</h2>

<p>C# generics, on the other hand, is a totally different beast. Indeed, the real type is kept at runtime and it is possible to use this type to write this kind of code:</p>

<pre><code class="csharp">/**
 * Filter objects of the given type
 */
public IEnumerable&lt;T&gt; FilterObjectsOfType&lt;T&gt;(IEnumerable&lt;object&gt; objects)
{
    List&lt;T&gt; filteredObjects = new List&lt;T&gt;();
    foreach (var obj in objects)
    {
        if (obj is T)
        {
            filteredObjects.Add((T) obj);    
        }
    }
    return filteredObjects;
} 
</code></pre>

<p>This method can be invoked like this:</p>

<pre><code class="csharp">IEnumerable&lt;String&gt; stringsOnly = FilterObjectsOfType&lt;String&gt;(new List&lt;object&gt;(new object[] { "hello", 2 }));
// stringsOnly contains only "hello"
</code></pre>

<h2>Conclusion</h2>

<p>In Java, generics are used to write type-safe code but this feature is limited and the code can be awkward sometimes due to the type erasure mechanism. In C#, it is a runtime feature and its usage is much more straightforward.</p>

<p><em>PS: I realize that the code I wrote in the snippets is not really idiomatic but I wanted to have Java and C# code as similar as possible to be able to focus only on the usage of generics.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C# for the Java Developer: Extension Methods]]></title>
    <link href="https://rnowif.github.io/blog/2018/10/20/c-sharp-for-the-java-developer-extension-methods/"/>
    <updated>2018-10-20T01:20:24+13:00</updated>
    <id>https://rnowif.github.io/blog/2018/10/20/c-sharp-for-the-java-developer-extension-methods</id>
    <content type="html"><![CDATA[<p>After spending several years crafting Java code, I recently decided to dive back into C# and share what I learn in the process. In this blog post, I will talk about extensions methods. This concept, which exists in some JVM languages (like <a href="https://kotlinlang.org/docs/reference/extensions.html">Kotlin</a>) but not in Java, let the developer add methods to a class without touching its code (hence the name <em>extension</em> methods).</p>

<!-- more -->


<p>Let&rsquo;s say you want to create a method that puts the first letter of a string in upper case and returns the new string. You cannot modify (or even inherit) the <code>String</code> class in Java to add this method. Since you don&rsquo;t necessarily want to create your own custom flavour of the <code>String</code> class for your code base, you would probably create a static function that takes a <code>String</code> as an argument and return another <code>String</code>:</p>

<pre><code class="java">class StringExtensions {
    static String capitalize(String word) {
        return Character.toUpperCase(word.charAt(0)) + word.substring(1);
    }
}
</code></pre>

<p>Now, you can simply invoke this function like this:</p>

<pre><code class="java">String word = "hello";
String capitalizedWord = StringExtensions.capitalize(word);
</code></pre>

<p>Of course, creating a static method is also possible in C#. However, C# has a feature that allows to add new methods to a class without having to modify its code. This feature is called <em>extension methods</em>. In order to create an extension method, you have to create a top-level static class and implement a static method. The first argument of this method specifies the type that the method operates on and should have the <code>this</code> modifier:</p>

<pre><code class="csharp">static class StringExtensions 
{
  static string Capitalize(this String word)
  {
      // Note that this cannot access any private data in the String class. 
      return char.ToUpper(word[0]) + word.Substring(1);
  }
}
</code></pre>

<p>In order to use it, the namespace that contains the class must be specified with a <code>using</code> directive. Afterwards, the method can be invoked as if it was an instance method of the type:</p>

<pre><code class="csharp">string word = "hello";
string capitalizedWord = word.Capitalize();
</code></pre>

<p>Extension methods are very powerful. Beside the fact that the code looks &ldquo;cleaner&rdquo;, it is also possible to seamlessly plug new behaviours in existing types by simply importing a namespace. The extension code can be in separate specific modules that can be imported only when needed.</p>
]]></content>
  </entry>
  
</feed>
