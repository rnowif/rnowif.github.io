<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: concurrency | Renaud Humbert-Labeaumaz]]></title>
  <link href="https://rnowif.github.io/blog/categories/concurrency/atom.xml" rel="self"/>
  <link href="https://rnowif.github.io/"/>
  <updated>2018-10-22T23:26:28+13:00</updated>
  <id>https://rnowif.github.io/</id>
  <author>
    <name><![CDATA[Renaud Humbert-Labeaumaz]]></name>
    <email><![CDATA[rnow.if@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What is a Volatile Variable in Java?]]></title>
    <link href="https://rnowif.github.io/blog/2018/09/21/what-is-a-volatile-variable-in-java/"/>
    <updated>2018-09-21T22:13:33+12:00</updated>
    <id>https://rnowif.github.io/blog/2018/09/21/what-is-a-volatile-variable-in-java</id>
    <content type="html"><![CDATA[<p>The <code>volatile</code> keyword is one of the less known and less understood keyword of the Java language. The goal of this article is to explain what it is and when to use it.</p>

<!-- more -->


<h2>Memory Architecture</h2>

<p>In order to understand the value of <code>volatile</code>, one must first understand the memory architecture of a computer:</p>

<p><img src="/images/memory_architecture.png"></p>

<p>Each CPU contains its own registers, which are basically in-CPU memory. Accessing these registers and performing operations on variables here is very fast.
Each CPU also has cache memory layers. It can access this cache memory fast, but not as fast as the registers.
Finally, there is the main memory (also called RAM). All CPUs can access this memory. The main memory is much bigger than the cache memories of the CPU.</p>

<p>Typically, when a CPU needs to read something from the memory, it will read it into its CPU cache memory and perform operations on it. It can even read it into its registers. When the CPU needs to write it back to the memory, it will flush its registers to the cache memory and eventually this cache memory will be flushed back to the main memory.</p>

<p>In general, the flush is performed when the CPU needs to make room for other information. Thus, it seems clear that one cannot make any assumption about <em>when</em> this flush will occur.</p>

<h2>Visibility of Shared Variables</h2>

<p>If a computer has 2 CPUs or more, it will be able to run several threads at the same time. It means that, if each thread want to access the same variable, each CPU will have a &ldquo;copy&rdquo; of this variable into its cache memory and this could lead to a major synchronization issue.</p>

<p>Take this code for instance:</p>

<pre><code class="java">public class MyServer implements Runnable {
    private boolean running = true;

    @Override
    public void run() {
        while (running) {
            // Do some very interesting stuff...
        }
    }

    public void stop() {
        running = false;
    }
}
</code></pre>

<p>It is very likely that the <code>stop</code> method will be called from a different thread than the one executing the <code>run</code> method. If these threads are executed on 2 different CPUs, the <code>run</code> method will not stop until the CPU has flushed its cache memory to the main memory. And we saw that there is no way to predict when this will happen.</p>

<p>In Java, the <code>volatile</code> keyword explicitely ask for a variable to be directly wrote to the main memory, and thus becoming instantely available for all CPUs.</p>

<p>The code then become:</p>

<pre><code class="java">public class MyServer implements Runnable {
    private volatile boolean running = true;

    @Override
    public void run() {
        while (running) {
            // Do some very interesting stuff...
        }
    }

    public void stop() {
        running = false;
    }
}
</code></pre>

<p>Note that a volatile variable can be a primitive or an object and can be <code>null</code>.</p>

<h2>When to Use <code>volatile</code></h2>

<p> A volatile variable is guaranteed to have its last version always available from every CPUs. It is typically used for flags that are modified by a thread and read by another one (like the <code>running</code> boolean in the previous snippet). Globally, you may use a <code>volatile</code> variable if the variable may be accessed by several threads and you don&rsquo;t need to perform a sequence of operations in an atomic manner (you should not increment a <code>volatile</code> variable for instance). If you need to do so, you should consider using a synchronization mechanism.</p>

<h2>Conclusion</h2>

<p>The <code>volatile</code> keyword is seldomly used, maybe because messing with threads is frowned upon in a JEE (or Spring) application, but it can be very useful to know it and understand its usage. Indeed, it could make your code safer and prevent you from writing algorithms that rely on locks and synchronization where it&rsquo;s not really needed.</p>
]]></content>
  </entry>
  
</feed>
