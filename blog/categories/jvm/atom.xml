<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: jvm | Renaud Humbert-Labeaumaz]]></title>
  <link href="https://rnowif.github.io/blog/categories/jvm/atom.xml" rel="self"/>
  <link href="https://rnowif.github.io/"/>
  <updated>2018-10-23T10:10:12+13:00</updated>
  <id>https://rnowif.github.io/</id>
  <author>
    <name><![CDATA[Renaud Humbert-Labeaumaz]]></name>
    <email><![CDATA[rnow.if@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C# for the Java Developer: Generics]]></title>
    <link href="https://rnowif.github.io/blog/2018/10/20/c-sharp-for-the-java-developer-generics/"/>
    <updated>2018-10-20T05:57:36+13:00</updated>
    <id>https://rnowif.github.io/blog/2018/10/20/c-sharp-for-the-java-developer-generics</id>
    <content type="html"><![CDATA[<p>In my journey into the C# world, I wanted to talk about generics. Generics exist in both Java and C# languages but their implementation is <em>very</em> different. This blog post aims to explain the differences and the similarities between the two.<br/>
TL;DR Java generics is a lie, C# generics is not.</p>

<!-- more -->


<h2>Java Generics is a Lie</h2>

<p>Generics have been introduced in Java 5. Before that, you had to manipulate <code>Objects</code> and cast them to the desired type:</p>

<pre><code class="java">List apples = new ArrayList();
apples.add(new Apple());
// This is really a list of objects, so the cast is required
Apple firstApple = (Apple) apples.get(0);
</code></pre>

<p>In the previous snippet, you should note that there is absolutely nothing that prevents you from adding a <code>Banana</code> into the list and make the program crash at runtime. Also, this code is still valid in the latest version of Java (which is Java 11 as we speak). To say the least, this approach is not very safe and do not leverage the type system as much as we could expect.</p>

<p>Since Java 5, it is then possible to use the generic version of the <code>List</code> class:</p>

<pre><code class="java">List&lt;Apple&gt; apples = new ArrayList&lt;Apple&gt;();
apples.add(new Apple());
// The cast is not required any more thanks to the generics
Apple firstApple = apples.get(0);
</code></pre>

<p>The thing is that, at runtime, the two previous snippets are strictly equivalent. Indeed, Java generics are removed during compilation and the resulting bytecode only manipulate <code>Objects</code> and casts. This is called <em>type erasure</em>. As a consequence, it is not possible, in Java, to write code like this:</p>

<pre><code class="java">/**
 * Filter objects of the given type
 */
&lt;T&gt; List&lt;T&gt; filterObjectsOfType(List&lt;Object&gt; objects) {
    List&lt;T&gt; filteredObjects = new ArrayList&lt;&gt;();
    for (Object o : objects) {
        if (o instanceof T) {
            filteredObjects.add((T) o);
        }
    }
    return filteredObjects;
}
</code></pre>

<p>Indeed, the type of <code>T</code> is erased at runtime and the <code>instanceof</code> operation cannot be performed. That is why a class object is often passed as an argument of the method:</p>

<pre><code class="java">/**
 * Filter objects of the given type
 */
&lt;T&gt; List&lt;T&gt; filterObjectsOfType(List&lt;Object&gt; objects, Class&lt;T&gt; clazz) {
    List&lt;T&gt; filteredObjects = new ArrayList&lt;&gt;();
    for (Object o : objects) {
        if (clazz.isInstance(o)) {
            filteredObjects.add((T) o);
        }
    }
    return filteredObjects;
}
</code></pre>

<p>This method can be invoked like this:</p>

<pre><code class="java">List&lt;String&gt; stringsOnly = filterObjectsOfType(Arrays.asList("hello", 2), String.class);
// stringsOnly contains only "hello"
</code></pre>

<h2>C# Generics is a Runtime Feature</h2>

<p>C# generics, on the other hand, is a totally different beast. Indeed, the real type is kept at runtime and it is possible to use this type to write this kind of code:</p>

<pre><code class="csharp">/**
 * Filter objects of the given type
 */
public IEnumerable&lt;T&gt; FilterObjectsOfType&lt;T&gt;(IEnumerable&lt;object&gt; objects)
{
    List&lt;T&gt; filteredObjects = new List&lt;T&gt;();
    foreach (var obj in objects)
    {
        if (obj is T)
        {
            filteredObjects.Add((T) obj);    
        }
    }
    return filteredObjects;
} 
</code></pre>

<p>This method can be invoked like this:</p>

<pre><code class="csharp">IEnumerable&lt;String&gt; stringsOnly = FilterObjectsOfType&lt;String&gt;(new List&lt;object&gt;(new object[] { "hello", 2 }));
// stringsOnly contains only "hello"
</code></pre>

<h2>Conclusion</h2>

<p>In Java, generics are used to write type-safe code but this feature is limited and the code can be awkward sometimes due to the type erasure mechanism. In C#, it is a runtime feature and its usage is much more straightforward.</p>

<p><em>PS: I realize that the code I wrote in the snippets is not really idiomatic but I wanted to have Java and C# code as similar as possible to be able to focus only on the usage of generics.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What is a Volatile Variable in Java?]]></title>
    <link href="https://rnowif.github.io/blog/2018/09/21/what-is-a-volatile-variable-in-java/"/>
    <updated>2018-09-21T22:13:33+12:00</updated>
    <id>https://rnowif.github.io/blog/2018/09/21/what-is-a-volatile-variable-in-java</id>
    <content type="html"><![CDATA[<p>The <code>volatile</code> keyword is one of the less known and less understood keyword of the Java language. The goal of this article is to explain what it is and when to use it.</p>

<!-- more -->


<h2>Memory Architecture</h2>

<p>In order to understand the value of <code>volatile</code>, one must first understand the memory architecture of a computer:</p>

<p><img src="/images/memory_architecture.png"></p>

<p>Each CPU contains its own registers, which are basically in-CPU memory. Accessing these registers and performing operations on variables here is very fast.
Each CPU also has cache memory layers. It can access this cache memory fast, but not as fast as the registers.
Finally, there is the main memory (also called RAM). All CPUs can access this memory. The main memory is much bigger than the cache memories of the CPU.</p>

<p>Typically, when a CPU needs to read something from the memory, it will read it into its CPU cache memory and perform operations on it. It can even read it into its registers. When the CPU needs to write it back to the memory, it will flush its registers to the cache memory and eventually this cache memory will be flushed back to the main memory.</p>

<p>In general, the flush is performed when the CPU needs to make room for other information. Thus, it seems clear that one cannot make any assumption about <em>when</em> this flush will occur.</p>

<h2>Visibility of Shared Variables</h2>

<p>If a computer has 2 CPUs or more, it will be able to run several threads at the same time. It means that, if each thread want to access the same variable, each CPU will have a &ldquo;copy&rdquo; of this variable into its cache memory and this could lead to a major synchronization issue.</p>

<p>Take this code for instance:</p>

<pre><code class="java">public class MyServer implements Runnable {
    private boolean running = true;

    @Override
    public void run() {
        while (running) {
            // Do some very interesting stuff...
        }
    }

    public void stop() {
        running = false;
    }
}
</code></pre>

<p>It is very likely that the <code>stop</code> method will be called from a different thread than the one executing the <code>run</code> method. If these threads are executed on 2 different CPUs, the <code>run</code> method will not stop until the CPU has flushed its cache memory to the main memory. And we saw that there is no way to predict when this will happen.</p>

<p>In Java, the <code>volatile</code> keyword explicitely ask for a variable to be directly wrote to the main memory, and thus becoming instantely available for all CPUs.</p>

<p>The code then become:</p>

<pre><code class="java">public class MyServer implements Runnable {
    private volatile boolean running = true;

    @Override
    public void run() {
        while (running) {
            // Do some very interesting stuff...
        }
    }

    public void stop() {
        running = false;
    }
}
</code></pre>

<p>Note that a volatile variable can be a primitive or an object and can be <code>null</code>.</p>

<h2>When to Use <code>volatile</code></h2>

<p> A volatile variable is guaranteed to have its last version always available from every CPUs. It is typically used for flags that are modified by a thread and read by another one (like the <code>running</code> boolean in the previous snippet). Globally, you may use a <code>volatile</code> variable if the variable may be accessed by several threads and you don&rsquo;t need to perform a sequence of operations in an atomic manner (you should not increment a <code>volatile</code> variable for instance). If you need to do so, you should consider using a synchronization mechanism.</p>

<h2>Conclusion</h2>

<p>The <code>volatile</code> keyword is seldomly used, maybe because messing with threads is frowned upon in a JEE (or Spring) application, but it can be very useful to know it and understand its usage. Indeed, it could make your code safer and prevent you from writing algorithms that rely on locks and synchronization where it&rsquo;s not really needed.</p>
]]></content>
  </entry>
  
</feed>
