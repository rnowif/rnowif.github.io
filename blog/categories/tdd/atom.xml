<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tdd | Renaud Humbert-Labeaumaz]]></title>
  <link href="https://rnowif.github.io/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="https://rnowif.github.io/"/>
  <updated>2018-11-03T08:44:00+13:00</updated>
  <id>https://rnowif.github.io/</id>
  <author>
    <name><![CDATA[Renaud Humbert-Labeaumaz]]></name>
    <email><![CDATA[rnow.if@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pourquoi utiliser le TDD est une bonne idée pour apprendre un nouveau langage]]></title>
    <link href="https://rnowif.github.io/blog/2016/12/27/pourquoi-utiliser-le-tdd-pour-apprendre-langage/"/>
    <updated>2016-12-27T05:44:15+13:00</updated>
    <id>https://rnowif.github.io/blog/2016/12/27/pourquoi-utiliser-le-tdd-pour-apprendre-langage</id>
    <content type="html"><![CDATA[<p>Durant ma dernière mission, j'ai eu à écrire du code dans des langages que je ne connaissais pas du tout, ou très peu (Ruby, Perl, Python, Go). J'ai donc expérimenté une technique qui consiste à apprendre un langage par les tests. Cette technique se nomme le <em>Test Driven Learning</em>.</p>

<p>L'objectif de cet article est de décrire pourquoi il peut être intéressant d'utiliser le TDD pour apprendre un nouveau langage de manière efficace.</p>

<!-- more -->


<h2>Découverte du langage</h2>

<p>Écrire un test est suffisamment complexe pour découvrir pas mal de spécificités du langage mais suffisamment simple pour ne pas avoir besoin de trop chercher.
En effet, il faut bien créer un fichier, éventuellement une classe, instancier un objet, créer et appeler une fonction, définir une variable, etc. Cependant, il est très rapidement possible d'écrire un test sans avoir besoin de connaître le langage en détail : pas besoin de boucle, de structure conditionnelle ou bien d'héritage. De plus, exécuter un test est en général bien plus simple que de déployer le code (sur un serveur ou en local) pour le tester &ldquo;à la main&rdquo;.</p>

<p>Par ailleurs, le fait de ne pas connaître le langage garantit que le test sera focalisé sur le comportement et donc totalement découplé de l'implémentation !</p>

<p>Ceci est un test en Ruby écrit avec le framework <a href="http://rspec.info/">rspec</a>. Ce test est pratiquement un copié / collé de l'exemple du tutoriel, adapté à mon contexte :</p>

<pre><code class="ruby">describe GoogleQueryParser do
  describe "extract query" do
    it "should return the query when other parameters are set afterwards" do
      parser = GoogleQueryParser.new
      expect(parser.parse("/search?q=kibana&amp;hl=fr")).to eq("kibana")
    end
  end
end
</code></pre>

<p>Après quelques essais, la structure est créée, le code est compilé et les tests sont lancés. L'implémentation peut commencer.</p>

<h2>Fil d'ariane</h2>

<p>Une fois le test écrit, il sert de fil rouge pour guider l'implémentation. Ceci est également vrai quand le TDD est utilisé avec un langage que l'on maîtrise mais, quand le langage est inconnu, il est plus facile de se détourner du droit chemin. Le test permet donc de se concentrer sur un objectif fixé et clairement exprimé. C'est un véritable bac à sable où il est possible d'expérimenter sans risque.</p>

<h2>Refactoring facilité</h2>

<p>Les premières lignes de code dans un nouveau langage sont rarement parfaites. Au fur et à mesure de l'apprentissage, il est possible de faire mieux. Cela tombe bien, car le TDD encourage justement à écrire une première implémentation qui fait seulement passer le test et refactorer ensuite.</p>

<p>Sans test, la découverte d'un nouveau langage peut être périlleuse. En effet, il est très simple d'écrire du code &ldquo;qui marche&rdquo; et de ne surtout plus le toucher après, de peur de tout casser. Dès son écriture, ce code est donc voué à être un fardeau pour toute l'équipe.</p>

<h2>Conclusion</h2>

<p>J'ai très souvent entendu des gens dire qu'ils ne faisaient pas de TDD car ils ne maîtrisaient pas assez le langage. Je pense au contraire que le TDD est un excellent moyen pour apprendre un langage ou un paradigme. Il permet de s'assurer un harnais de sécurité et d'expérimenter sans aucun risque. Tous les avantages du TDD semblent exacerbés lorsque le langage cible est peu ou pas connu. En somme, je pense qu'avoir appris le Ruby par le TDD m'a permis d'être à la fois meilleur en Ruby <strong>et</strong> en TDD, tout en étant bien plus productif, malgré le gap technique.</p>

<p>Si vous souhaitez aller plus loin dans le TDL, je vous conseille de lire l'<a href="https://ldez.github.io/blog/2015/12/04/test-driven-learning-go/">article</a> de <a href="https://twitter.com/ludnadez">Ludovic Fernandez</a>, où il apprend le Go par les tests.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ecrire des tests plus robustes au changement]]></title>
    <link href="https://rnowif.github.io/blog/2016/11/03/ecrire-des-tests-plus-robustes-au-changement/"/>
    <updated>2016-11-03T05:31:42+13:00</updated>
    <id>https://rnowif.github.io/blog/2016/11/03/ecrire-des-tests-plus-robustes-au-changement</id>
    <content type="html"><![CDATA[<p>Un des principaux freins à l'écriture de tests est quand ceux-ci doivent être mis à jour à chaque fois qu'une classe ou qu'une méthode est modifiée. Parfois, les tests à mettre à jour n'ont rien à voir avec la classe ou la méthode modifiée, mais comme ils s'en servent, ils s'en retrouvent affectés eux aussi. Ce problème survient quand le test est trop couplé à l'implémentation.
Dans cet article, nous allons voir comment découpler les tests des classes qu'ils utilisent et ainsi les rendre plus robustes.</p>

<!-- more -->


<h2>Méthode 0 : La méthode naïve</h2>

<p>Soit une classe qui doit tester si une personne a accès à une ressource ou non. L'API de la classe <code>Person</code> est maintenue par une autre équipe et est donc hors de contrôle.
La façon la plus naïve d'écrire le test pourrait être la suivante :</p>

<pre><code class="java">@Test
public void should_deny_access_when_underaged() {
  Person kid = new Person();
  kid.setAge(17);

  AuthorizationPolicy policy = new AuthorizationPolicy();

  Authorization authorization = policy.authorize(kid);

  assertThat(authorization, is(Authorization.DENY));
}
</code></pre>

<p>Si l'API de la classe <code>Person</code> évolue et prend l'âge directement en paramètre du constructeur, ce test ne compilera plus et devra être réécrit, ainsi que tous les autres tests qui instancient directement une <code>Person</code>.</p>

<h2>Méthode 1 : Utilisation d'une méthode de création</h2>

<p>La première solution serait d'utiliser une méthode de création partagée par tous les tests de la classe :</p>

<pre><code class="java">@Test
public void should_deny_access_when_underaged() {
  Person kid = newPerson(17);
  AuthorizationPolicy policy = new AuthorizationPolicy();

  Authorization authorization = policy.authorize(kid);

  assertThat(authorization, is(Authorization.DENY));
}

private Person newPerson(int age) {
  Person person = new Person();
  person.setAge(17);
  return person;
}
</code></pre>

<p>Ici, si l'API de <code>Person</code> change, seule la méthode est affectée. Tous les tests passeront sans difficulté une fois cette méthode modifiée.</p>

<p>Maintenant, la politique d'autorisation évolue pour refuser les mineurs, mais également les garçons (même majeurs). Le test devient alors :</p>

<pre><code class="java">@Test
public void should_deny_access_when_underaged() {
  Person kid = newPerson(17, Gender.FEMALE);
  AuthorizationPolicy policy = new AuthorizationPolicy();

  Authorization authorization = policy.authorize(kid);

  assertThat(authorization, is(Authorization.DENY));
}

@Test
public void should_deny_access_when_male_and_overaged() {
  Person maleAdult = newPerson(18, Gender.MALE);
  AuthorizationPolicy policy = new AuthorizationPolicy();

  Authorization authorization = policy.authorize(maleAdult);

  assertThat(authorization, is(Authorization.DENY));
}

private Person newPerson(int age, Gender gender) {
  Person person = new Person();
  person.setAge(age);
  person.setGender(gender);
  return person;
}
</code></pre>

<p>On remarque que le premier test a été modifié, bien que le sexe de la personne ne soit pas pertinent dans ce cas. Le code du premier test est donc moins expressif sur la règle métier testée. Si on augmente le nombre de paramètres dans la méthode <code>newPerson</code> l'expressivité et la robustesse des tests décroit de plus en plus. De plus, la méthode <code>newPerson</code> n'est pas directement réutilisable dans les autres classes de test.</p>

<h2>Méthode 2 : Utilisation d'un builder</h2>

<p>Cette méthode consiste à utiliser un <code>Builder</code> pour permettre de construire une instance de <code>Person</code> personnalisable à la demande.</p>

<p>Il suffit de créer une classe <code>PersonBuilder</code> :</p>

<pre><code class="java">
public class PersonBuilder {

  private int age;
  private Gender gender = Gender.FEMALE;

  public static PersonBuilder aPerson() {
    return new PersonBuilder();
  }

  public PersonBuilder withAge(int age) {
    this.age = age;
    return this;
  }

  public PersonBuilder withGender(Gender gender) {
    this.gender = gender;
    return this;
  }

  public Person build() {
    Person person = new Person();
    person.setAge(age);
    person.setGender(gender);
    return person;
  }
}
</code></pre>

<p>Les tests deviennent alors :</p>

<pre><code class="java">@Test
public void should_deny_access_when_underaged() {
  Person kid = aPerson().withAge(17).build();
  AuthorizationPolicy policy = new AuthorizationPolicy();

  Authorization authorization = policy.authorize(kid);

  assertThat(authorization, is(Authorization.DENY));
}

@Test
public void should_deny_access_when_male_and_overaged() {
  Person maleAdult = aPerson().withAge(18).withGender(Gender.MALE).build();
  AuthorizationPolicy policy = new AuthorizationPolicy();

  Authorization authorization = policy.authorize(maleAdult);

  assertThat(authorization, is(Authorization.DENY));
}
</code></pre>

<p>Désormais, les tests sont bien plus clairs sur leur intention car seuls les attributs nécessaires sont spécifiés. Les autres peuvent être <code>null</code> ou avoir des valeurs par défaut (ici, le sexe est féminin par défaut par exemple). De plus, la logique d'instanciation d'une <code>Person</code> est située à un seul endroit dans les tests et seul le builder serait affecté si l'API venait à changer.</p>

<h2>Conclusion</h2>

<p>Les méthodes décrites dans cet article permettent de découpler les tests des logiques d'instanciation des objets nécessaires. Elles sont particulièrement utiles lors de l'utilisation d'API tierces qui ne sont pas toujours très stables ni très bien conçues. Grâce à elles, les tests sont plus expressifs, plus robustes et plus concis.</p>
]]></content>
  </entry>
  
</feed>
