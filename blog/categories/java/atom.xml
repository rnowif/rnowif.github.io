<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Renaud Humbert-Labeaumaz]]></title>
  <link href="https://rnowif.github.io/blog/categories/java/atom.xml" rel="self"/>
  <link href="https://rnowif.github.io/"/>
  <updated>2016-11-18T17:07:19+01:00</updated>
  <id>https://rnowif.github.io/</id>
  <author>
    <name><![CDATA[Renaud Humbert-Labeaumaz]]></name>
    <email><![CDATA[renaud.humbert-labeaumaz@zenika.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Implémenter Un Mécanisme d’AOP, Sans Framework !]]></title>
    <link href="https://rnowif.github.io/blog/2016/11/03/laop-demystifie/"/>
    <updated>2016-11-03T07:55:27+01:00</updated>
    <id>https://rnowif.github.io/blog/2016/11/03/laop-demystifie</id>
    <content type="html"><![CDATA[<p>L'<em>Aspect Oriented Programming</em> est un paradigme de programmation qui permet de traiter les préoccupations transverses (ou <em>cross cutting concerns</em> en anglais) telles que le logging, le cache ou les transactions séparément du code métier.</p>

<p>L'AOP repose la plupart du temps sur l'utilisation de librairies ou de frameworks qui rendent ce type de programmation assez obscur et parfois difficile à comprendre. L'objectif de cet article est d'expliquer comment cela fonctionne afin de le démystifier.</p>

<!-- more -->


<p>L'ensemble du code montré dans cet article est accessible sur ce repo <a href="https://github.com/rnowif/demo-aop">GitHub</a>.</p>

<h2>Pourquoi l'AOP ?</h2>

<p>Pour cet article, nous allons partir d'une classe qui implémente la suite de Fibonacci et dont on veut calculer le temps d'exécution.
De manière naïve, il serait possible de calculer et logger ce temps d'exécution directement dans la méthode (<a href="https://github.com/rnowif/demo-aop/tree/63660763cdb1f1d97e3ba63e9c5a271a60d53a99">voir le commit</a>):</p>

<pre><code class="java">public class FibonacciCalculatorImpl implements FibonacciCalculator {

    private static final Logger LOG = LoggerFactory.getLogger(FibonacciCalculatorImpl.class);

    @Override
    public int calculate(int n) {
        StopWatch watch = new StopWatch(Clock.systemDefaultZone());
        watch.start();
        LOG.info("Start calculation for number {}", n);
        int result = n;
        if (n &gt; 1) {
            result = calculate(n-1) + calculate(n-2);
        }
        LOG.info("End calculation for number {} ({} ms)", n, watch.elapsed());
        return result;
    }
}
</code></pre>

<p>Ce code pose plusieurs problèmes : le <em>tangling</em> et le <em>scattering</em>.</p>

<h3><em>Code tangling</em></h3>

<p>Le <em>code tangling</em> signifie que le code contient différentes notions qui sont mélangées : la mesure du temps et le métier. On pourrait en imaginer d'autres comme la gestion des transactions, le cache ou le monitoring.</p>

<p>Ceci est problématique car le code métier, qui apporte la vraie valeur, est noyé dans du code de &ldquo;plomberie&rdquo; qui peut finir par prendre beaucoup plus de place que le code initial !</p>

<h3><em>Code scattering</em></h3>

<p>Le <em>code scattering</em> signifie que le code non métier sera sans nul doute réécrit dans beaucoup de méthodes. On voit alors émerger un grand nombre de duplications de code, qui le rendent très difficile à maintenir.</p>

<h2>Le pattern <em>Proxy</em></h2>

<p>La première amélioration évidente qu'il est possible d'apporter est d'extraire la logique de calcul du temps dans une classe spécifique, qui va implémenter la même interface que <code>FibonacciCalculatorImpl</code> et déléguer l'appel de la méthode <code>calculate</code> à une instance de <code>FibonacciCalculatorImpl</code>. Il s'agit du pattern <em>Proxy</em> (<a href="https://github.com/rnowif/demo-aop/tree/a4d00f2b5b0a2cb28196a738ece906560546bda5">voir le commit</a>).</p>

<pre><code class="java">public class TimedFibonacciCalculator implements FibonacciCalculator {

    private static final Logger LOG = LoggerFactory.getLogger(FibonacciCalculatorImpl.class);

    private final FibonacciCalculator calculator;

    public TimedFibonacciCalculator(FibonacciCalculator calculator) {
        this.calculator = calculator;
    }

    @Override
    public int calculate(int n) {
        StopWatch watch = new StopWatch(Clock.systemDefaultZone());
        watch.start();
        LOG.info("Start calculation for number {}", n);
        int result = calculator.calculate(n); // Delegate calculation
        LOG.info("End calculation for number {} ({} ms)", n, watch.elapsed());
        return result;
    }
}
</code></pre>

<p>L'utilisation de cette classe se fait comme suit :</p>

<pre><code class="java">FibonacciCalculator calculator = new TimedFibonacciCalculator(new FibonacciCalculatorImpl());
LOG.info("10th fibonacci number : {}", calculator.calculate(10));
</code></pre>

<p>L'utilisation de ce pattern règle le problème du <em>code tangling</em> mais pas du tout celui du <em>code scattering</em>. En effet, cette classe <code>TimedFibonacciCalculator</code> n'est pas vraiment réutilisable car elle est fortement couplée à l'interface <code>FibonacciCalculator</code>.</p>

<h2>Externalisation de la logique de chronométrage</h2>

<p>Pour résoudre le <em>code scattering</em>, il faut extraire la logique de mesure du temps et lui permettre d'appeler n'importe quelle méthode (<a href="https://github.com/rnowif/demo-aop/tree/fb545b1a3af8e34b37e8f93f4abf97b57ae75f33">voir le commit</a>). On peut, pour cela, définir une interface fonctionnelle générique qui contient une méthode <code>invoke</code>.</p>

<pre><code class="java">@FunctionalInterface
public interface InvocationPoint&lt;T&gt; {

    T invoke() throws Exception;
}
</code></pre>

<p>Cette interface pourra alors être injectée dans une classe réutilisable, permettant de mesurer le temps nécessaire à l'exécution de la méthode <code>invoke</code> :</p>

<pre><code class="java">public class TimedInvocation {

    private static final Logger LOG = LoggerFactory.getLogger(TimedInvocation.class);

    public &lt;T&gt; T invoke(InvocationPoint&lt;T&gt; invocationPoint) {
        StopWatch watch = new StopWatch(Clock.systemDefaultZone());
        watch.start();
        LOG.info("Start calculation");
        T result = invocationPoint.invoke();
        LOG.info("End calculation ({} ms)", watch.elapsed());
        return result;
    }
}
</code></pre>

<p>Le <em>proxy</em> ne sert donc plus que de passe-plat pour appeler cette classe (l'interface <code>InvocationPoint</code> peut aisément être implémentée par un lambda):</p>

<pre><code class="java">public class TimedFibonacciCalculator implements FibonacciCalculator {

    private final FibonacciCalculator calculator;

    public TimedFibonacciCalculator(FibonacciCalculator calculator) {
        this.calculator = calculator;
    }

    @Override
    public int calculate(int n) {
        return new TimedInvocation().invoke(
                () -&gt; calculator.calculate(n)
        );
    }
}
</code></pre>

<p>On remarque ici que le message de log est plus générique : il n'est plus possible de tracer l'index de la suite que l'on veut calculer. En effet, ce log est très générique et peut permettre de mesurer le temps d'exécution de n'importe quelle méthode.</p>

<h2>Génération automatique de <em>proxy</em></h2>

<p>Le <em>tangling</em> et le <em>scattering</em> sont éliminés mais il faut tout de même créer une classe de <em>proxy</em> pour chaque méthode que l'on souhaite chronométrer. Le mécanisme de <em>JDKProxy</em>, inclus directement dans le JDK, permet de créer des <em>proxys</em> dynamiques à partir d'une interface (<code>FibonacciCalculator</code>) et d'une implémentation de <code>InvocationHandler</code> (<a href="https://github.com/rnowif/demo-aop/tree/88dda77b942cc9370762d3e2efb79b6b9c0c6aeb">voir le commit</a>). Celle-ci contient une méthode <code>invoke(Object proxy, Method method, Object[] args): Object</code> qui prend en paramètre le proxy, la méthode qui a été apelée ainsi que ses arguments et doit retourner le résultat de l'appel de la méthode.</p>

<p>Le plus simple des <code>InvocationHandler</code>, qui ne fait rien, peut s'écrire comme ceci :</p>

<pre><code class="java">public class SimpleInvocationHandler implements InvocationHandler {

    private final Object target;

    public SimpleInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        return method.invoke(target, args);
    }
}
</code></pre>

<p>La création du proxy se fait ainsi :</p>

<pre><code class="java">FibonacciCalculator calculator = (FibonacciCalculator) Proxy.newProxyInstance(
  FibonacciCalculator.class.getClassLoader(),
  new Class[] {FibonacciCalculator.class},
  new SimpleInvocationHandler(new FibonacciCalculatorImpl())
);
</code></pre>

<p>Dans notre cas, le handler va devoir calculer le temps d'exécution de la méthode. Il s'écrit donc ainsi :</p>

<pre><code class="java">public class TimedInvocationHandler implements InvocationHandler {

    private final Object target;

    public TimedInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        return new TimedInvocation().invoke(
                () -&gt; method.invoke(target, args)
        );
    }
  }
}
</code></pre>

<h2>Activer ou désactiver la mesure du temps</h2>

<p>Pour faire comme les pros (sic !), il est possible d'activer ou désactiver la mesure du temps sur une méthode en y ajoutant une annotation <code>@Timed</code> qui servira de marqueur.</p>

<pre><code class="java">public class FibonacciCalculatorImpl implements FibonacciCalculator {

    @Timed
    @Override
    public int calculate(int n) {
        int result = n;
        if (n &gt; 1) {
            result = calculate(n-1) + calculate(n-2);
        }
        return result;
    }
}
</code></pre>

<p>Dans le handler, il suffit alors d'utiliser la reflection pour déterminer si la méthode est annotée ou non, et mesure le temps en conséquence :</p>

<pre><code class="java">public class TimedInvocationHandler implements InvocationHandler {
    private static final Class&lt;Timed&gt; ANNOTATION_CLASS = Timed.class;

    private final Object target;

    public TimedInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (isTimed(method)) {
            return new TimedInvocation().invoke(
                    () -&gt; method.invoke(target, args)
            );
        }

        // Method not annotated, just invoke target
        return method.invoke(target, args);
    }

    private boolean isTimed(Method method) throws NoSuchMethodException {
        // Is timed if the interface method or the target method is annotated
        return method.getDeclaredAnnotation(ANNOTATION_CLASS) != null
                || target.getClass().getDeclaredMethod(method.getName(), method.getParameterTypes()).getDeclaredAnnotation(ANNOTATION_CLASS) != null;
    }
}
</code></pre>

<p>Pour rappel, une annotation n'est qu'un marqueur. La magie n'est pas dans l'annotation mais dans le code qui l'utilise !</p>

<h2>Conclusion</h2>

<h3>A propos de l'AOP</h3>

<p>Cet article a, de manière assez rudimentaire, permis d’implémenter un mécanisme d’AOP sans avoir recours à aucun framework externe. Néanmoins, il permet de comprendre certains aspects et limitations de l’AOP.</p>

<p>En effet, il est très simple de créer des proxys dynamiques avec JDKProxy lorsque la classe cible implémente une interface. Lorsque ce n’est pas le cas, le proxy doit étendre cette classe et surcharger la méthode à proxifier (il est possible d’utiliser une librairie comme <a href="https://github.com/cglib/cglib">CGLib</a> pour faire ça automatiquement).
Par aileurs, l’AOP implémenté grâce à ce mécanisme ne peut pas fonctionner sur des méthodes ou des classes privées ou finales. En effet, la méthode doit être définie dans une interface ou pouvoir être surchargée. De plus, si la classe à proxifier appelle directement une méthode de sa propre classe, notre AOP ne s’applique pas. Ici, la méthode calculate est récursive. Cependant, la mesure du temps ne s’opère que si la méthode est appelée à travers le proxy. Donc, seul l’appel de la méthode par &ldquo;l’extérieur&rdquo; est chronométré.</p>

<p>Certains autres mécanismes permettent de s’affranchir de ces contraintes en modifiant directement le code généré. Cette opération, appelée tissage, peut être effectuée à la compilation ou au runtime grâce à des librairies et instrumentations diverses.</p>

<h3>AspectJ et Spring AOP</h3>

<p><a href="http://www.eclipse.org/aspectj/">AspectJ</a> est un framework qui permet de faire de l’AOP grâce au tissage. Spring, quant à lui, utilise abondamment l’AOP grâce au mécanisme de proxy décrit dans cet article (avec les annotations <code>@Transactional</code>, <code>@Cacheable</code>, etc.). Il va parcourir l’ensemble des beans du contexte d’application et les remplacer par des <em>proxys</em> dynamiques. Ainsi, les beans que l’application manipule ne sont pas les implémentations brutes, mais des proxys (plus d’information sur les <em>proxys</em> AOP avec Spring <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/aop.html#aop-understanding-aop-proxies">ici</a>). Spring permet également de faire de l’AspectJ.</p>

<h3>Note finale</h3>

<p>L'AOP n'est pas magique, ni très complexe. Cependant, il est très fortement utilisé dans les framework de type Spring. Une bonne compréhension de ses mécanismes et de son implémentation permet de faciliter grandement le dévelopement et le debug des applications d'entreprise.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Quoi De Neuf Dans Spring 5]]></title>
    <link href="https://rnowif.github.io/blog/2016/07/30/quoi-de-neuf-dans-spring-5/"/>
    <updated>2016-07-30T14:05:38+02:00</updated>
    <id>https://rnowif.github.io/blog/2016/07/30/quoi-de-neuf-dans-spring-5</id>
    <content type="html"><![CDATA[<p>Juergen Hoeller a annoncé hier <a href="https://spring.io/blog/2016/07/28/spring-framework-5-0-m1-released">la sortie de Spring 5.0 M1</a>. Cette nouvelle version majeure de Spring arrive avec son lot de nouveautés.
L'objectif de cet article est de découvrir ces nouveautés et ce qu'elles peuvent apporter aux développeurs Spring. Les nouveautés décrites dans cet article sont déjà disponibles dans la version 5.0.M1.</p>

<!-- more -->


<h2>Modification des prérequis</h2>

<p>Spring 5 étant une version majeure, l'équipe s'est permise de modifier les pré-requis et d'abandonner le support pour des librairies obsolètes. A noter que la version 4.3 est supportée jusqu'en 2020 environ pour ceux qui ne pourraient pas mettre à jour leur application.</p>

<h3>Java 8 et Java 9</h3>

<p>Le changement principal au niveau des prérequis est la réécriture partielle de Spring en Java 8. De fait, il n'est pas possible d'utiliser Spring 5 avec une version antérieure de Java. Ce changement a ravi les développeurs Spring, comme on peut s'en douter (Spring 4.3 était en effet développé pour être compatible avec Java 6 !).</p>

<blockquote class="twitter-tweet" data-partner="tweetdeck"><p lang="en" dir="ltr">Current status: working in the <a href="https://twitter.com/springframework">@springframework</a> codebase with Java8 - I so much feel like a kid in a candy store right now!</p>&mdash; Stéphane Nicoll (@snicoll) <a href="https://twitter.com/snicoll/status/750332049492500480">July 5, 2016</a></blockquote>


<script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>Le passage à Java 8 a permis d'ajouter des méthodes par défaut à certaines interfaces centrales de Spring. Par exemple, l'interface <code>BeanPostProcessor</code>, qui permet de pouvoir modifier un bean après son instanciation, voit ses deux méthodes retourner le bean initial par défaut. Il est ainsi possible d'implémenter seulement <code>postProcessBeforeInitialization</code>, qui modifie le bean avant l'appel de la méthode <code>@PostConstruct</code>, ou bien seulement <code>postProcessAfterInitialization</code>, qui modifie le bean après l’appel de la méthode <code>@PostConstruct</code>.</p>

<pre><code class="java">public interface BeanPostProcessor {
  default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
    return bean;
  }
  default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    return bean;
  }
}
</code></pre>

<p>De plus, Java 8 a aussi introduit les lambdas, qui sont désormais utilisées dans les API Spring, comme par exemple le message d'erreur des méthodes de la classe <code>org.springframework.util.Assert</code> qui peut être évalué de manière <em>lazy</em> grâce à un <code>Supplier</code>.</p>

<pre><code class="java">Assert.isTrue(contextPath.startsWith("/"), () -&gt; "contextPath '" + contextPath + "' must start with '/'.");
</code></pre>

<p>Pour le moment, Java 8 est utilisé avec parcimonie mais nul doute que son usage va se généraliser dans les mois à venir pour améliorer l'expérience développeur des utilisateurs de Spring.</p>

<h4>Java 7</h4>

<p>Comme dit ci-dessus, Spring était compatible avec Java 6 jusqu'à la version 4, le passage à Java 8 a donc également permis de mettre à jour la base de code pour utiliser les fonctionnalités Java 7 (qui sont principalement des sucres syntaxiques) comme par exemple l'opérateur diamant, le <em>multicatch</em>, le <em>try-with-resources</em> ou l'utilisation de <code>StandardCharsets</code> au lieu de <code>String</code> pour définir les encodages.</p>

<h4>Java 9</h4>

<p>Finalement, Spring 5 continue de suivre les avancées de Java 9 pour rester le plus à jour possible dans son support. Par exemple, en Java 9, la méthode <code>Class.newInstance()</code> est dépréciée au profit de <code>Constructor.newInstance()</code> qui retourne une exception <code>InvocationTargetException</code> au lieu de propager l'exception utilisateur. Les classes Spring qui doivent instancier des beans arbitraires devront donc utiliser la nouvelle façon de faire.</p>

<h3>JPA 2.1 et Hibernate 5</h3>

<p>JPA 2.1 a presque 4 ans. Spring 5 essaie d'éviter les compromis avec la compatibilité et a donc établi JPA 2.1 comme prérequis. De fait, Hibernate 5 est obligatoire.</p>

<h3>Abandon du support</h3>

<p>Dans la même logique d'alléger le support pour des librairies obsolètes ou pas à jour, Spring 5 abandonne le support pour de nombreuses librairies dont PortletMVC, JDO, Guava caching, JasperReports, OpenJPA, Tiles 2, XMLBeans, Velocity.</p>

<h2>Programmation réactive</h2>

<p>La programmation réactive a le vent en poupe en ce moment et Spring 5 n'échappe pas à la règle. Le projet Spring Reactive a été mergé dans Spring Framework et permet désormais d'utiliser ses capacités dans Spring. De fait, Spring 5 permet désormais de sérialiser et désérialiser en XML (JAXB) et en Json (Jackson) de manière réactive et fournit un framework web et un <code>WebClient</code> réactifs.</p>

<p>Le framework Spring Web Reactive et le bien connu Spring Web MVC ne partagent pas de code car le paradigme de programmation est fondamentalement différent. Cependant, l'API est très proche, pour une plus grande cohérence et une prise en main plus rapide pour les utilisateurs de ce framework.</p>

<p>Voici par exemple à quoi ressemble un controller qui stream des données depuis un serveur de manière non bloquante et réactive.</p>

<pre><code class="java">@GetMapping("/accounts/{id}/alerts")
public Flux&lt;Alert&gt; getAccountAlerts(@PathVariable Long id) {

  return this.repository.getAccount(id)
      .flatMap(account -&gt;
          this.webClient
              .perform(get("/alerts/{key}", account.getKey()))
              .extract(bodyStream(Alert.class)));
}
</code></pre>

<p>Pour en savoir plus sur la programmation réactive avec Spring, se référer aux billets de blog <a href="https://spring.io/blog/2016/07/28/reactive-programming-with-spring-5-0-m1">Reactive Programming with Spring 5.0 M1</a> et <a href="https://spring.io/blog/2016/04/19/understanding-reactive-types">Understanding Reactive types</a>.</p>

<p>Pour information, un starter <em>Reactive Web</em> a été ajouté au <a href="http://start.spring.io">starter Spring Boot</a> en version 1.4+ de Spring Boot. Plus d'informations <a href="https://github.com/bclozel/spring-boot-web-reactive">ici</a>.</p>

<h2>Tests</h2>

<p>Finalement, Spring 5 a ajouté le support de JUnit 5, notamment grâce à l'ajout d'une <a href="http://junit.org/junit5/docs/current/user-guide/#extensions">extension</a> Spring, à utiliser avec <code>@ExtendWith(SpringExtension.class)</code> ou alors <code>@SpringJUnitConfig</code> qui combine <code>@ExtendWith(SpringExtension.class)</code> et <code>@ContextConfiguration</code>.</p>

<h2>Conclusion</h2>

<p>Spring 5 est une version majeure de Spring et l'équipe de développement en a profité pour faire un grand ménage dans les dépendances et les librairies supportées. Cette version permet de profiter pleinement des nouvelles fonctionnalités de Java sans la frustration parfois apportée par la rétro-compatibilité. De plus, la fusion de Spring Reactive dans le framework offre aux développeurs un outil extrêmement puissant pour tirer bénéfice de la programmation réactive avec Spring.</p>

<p>Pour information, la version RELEASE est prévue pour mars 2017.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multiples Vues JSON Avec @JsonView]]></title>
    <link href="https://rnowif.github.io/blog/2015/04/14/multiples-vues-json-avec-at-jsonview/"/>
    <updated>2015-04-14T22:05:31+02:00</updated>
    <id>https://rnowif.github.io/blog/2015/04/14/multiples-vues-json-avec-at-jsonview</id>
    <content type="html"><![CDATA[<p>Le format <a href="http://fr.wikipedia.org/wiki/JavaScript_Object_Notation">Json</a> est de plus en plus utilisé aujourd'hui notamment dans les API de type REST qui offrent des services et retournent leurs résultats sous ce format. Afin d'éviter d'avoir à écrire la transformation en Json manuellement, il existe de nombreuses librairies permettant de faire cette transformation de manière automatique.</p>

<p>Dans cet article, nous allons voir comment utiliser la librairie <a href="http://jackson.codehaus.org/">Jackson</a> et notamment l'annotation <code>@JsonView</code> pour configurer plusieurs transformations pour un même objet. Nous allons également voir succintement comment intégrer cette annotation avec le framework <a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html">Spring MVC</a>.</p>

<!-- more -->


<h2>Convertir un objet en Json avec Jackson</h2>

<p>Le code suivant permet d'utiliser Jackson pour convertir un objet Java en Json de manière automatique.</p>

<pre><code class="java">public String toJson(Foo foo) {
    ObjectMapper mapper = new ObjectMapper();
    return mapper.writeValueAsString(foo);
}
</code></pre>

<h2>Introduction à @JsonView</h2>

<p>Lorsque Jackson convertit l'objet en Json, il prend en compte tous les champs de cet objet. Or, dans la vie courante, il est rarement pertinent de récupérer tous les champs dans le Json final (par exemple, le mot de passe d'un utilisateur) et il est souvent intéressant d'avoir deux sorties différentes en fonction du contexte (par exemple, un Json résumé et un détaillé avec plus de champs).</p>

<p>L'annotation <code>@JsonView</code> permet de définir des vues et associer chaque champ à une ou plusieurs vues. Ainsi, au moment de la conversion, on indique à Jackson quelle vue utiliser et seuls les champs associés à cette vue seront pris en compte.</p>

<h3>Mise en place des vues</h3>

<p>La vue Json doit être une classe, ainsi elle peut bénéficier de l'héritage. Si la vue A hérite de la vue B, tous les champs associés à la vue B seront pris en compte lorsqu'on va exporter la vue A.</p>

<p>Les vues peuvent être définies de la façon suivante.</p>

<pre><code class="java">public class JsonViews {

    public static class PublicView { };
    public static class InternalOnlyView extends PublicView { };

}
</code></pre>

<p>Il n'y a pas besoin de mettre quoi que ce soit dans les classes, une simple déclaration suffit. C'est pourquoi il est plus simple de les regrouper dans une classe. On remarque ici l'héritage qui permet d'indiquer que tout ce qui est public sera visible également dans la vue interne.</p>

<h3>Association d'une vue à un champ</h3>

<p>Pour associer une vue à un champ, il faut l'annoter avec <code>@JsonView</code> avec la vue en paramètre.</p>

<pre><code class="java">public class Foo {

    @JsonView(JsonViews.PublicView.class)
    private String name;

    @JsonView(JsonViews.InternalOnlyView.class)
    private String password;
}
</code></pre>

<p>Ensuite, pour indiquer à Jackson d'exporter seulement cette vue, il faut lui passer en paramètre au moment de la conversion.</p>

<pre><code class="java">public String toJsonPublic(Foo foo) {
    ObjectMapper mapper = new ObjectMapper();
    return mapper
        .writerWithView(JsonViews.PublicView.class)
        .writeValueAsString(foo);
}
</code></pre>

<p><em>NB : Il est possible de définir plusieurs vues pour un champ en les mettant entre crochets <code>@JsonView({View1.class, View2.class})</code>. Ainsi, ce champ sera pris en compte dans chacune des vues</em></p>

<h2>Intégration avec Spring MVC</h2>

<p>Dans un controller Spring MVC, il n'est pas utile d'utiliser le code de conversion écrit précédemment. En effet, Jackson est intégré avec Spring MVC. Il suffit d'annoter la méthode du controller avec <code>@JsonView</code> pour lui indiquer la vue à utiliser.</p>

<pre><code class="java">@RestController
public class FooController {

    @JsonView(JsonViews.PublicView.class)
    @RequestMapping (value = "/public/foo", method = RequestMethod.GET)
    public Foo getFoo() {
        return new Foo("name", "password");
    }
}
</code></pre>

<p>Un appel à <code>/public/foo</code> va automatiquement retourner un objet Json qui représente la vue publique de l'objet instancié dans la méthode.</p>

<h2>Conclusion</h2>

<p><code>@JsonView</code> est un outil très simple et très puissant qui permet d'avoir plusieurs représentations du même objet sans avoir à écrire de code autre que quelques annotations. De plus, son intégration avec Spring MVC le rend très peu intrusif et ne pollue pas le code avec des opérations de conversion.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Eviter Les Classes Utilitaires Et Les Appels Statiques]]></title>
    <link href="https://rnowif.github.io/blog/2015/03/30/eviter-les-classes-utilitaires-et-les-appels-statiques/"/>
    <updated>2015-03-30T22:14:16+02:00</updated>
    <id>https://rnowif.github.io/blog/2015/03/30/eviter-les-classes-utilitaires-et-les-appels-statiques</id>
    <content type="html"><![CDATA[<p>De manière générale, les appels statiques sont des mauvaises pratiques car ils induisent notamment un fort couplage entre les classes et rendent les méthodes appelantes difficiles à tester. Cependant, il existe un cas d'utilisation qui utilise abondamment des appels statiques : il s'agit des classes utilitaires.</p>

<p>Cet article a pour objectif de voir comment et quand se passer des appels statiques aux classes utilitaires.</p>

<!-- more -->


<h2>De l'utilisation des classes utilitaires</h2>

<p>Les classes utilitaires sont utilisées absolument partout dans les programmes Java. Que ce soit les classes du JDK telles que <code>Math</code> ou <code>Arrays</code> ou bien celles de librairies externes comme <code>CollectionUtils</code> ou <code>FileUtils</code>, vous en avez forcément déjà utilisé.
Comme leur nom l'indique, ces classes sont très utiles pour effectuer des opérations courantes et sans état.</p>

<h2>Cas d'utilisation</h2>

<p>Pour illustrer mes propos, je vais prendre un cas d'utilisation assez classique : calculer le hash d'un mot de passe avant insertion en base de données. Ce cas d'utilisation semble être éligible à l'utilisation d'une classe utilitaire.</p>

<h3>Utilisation d'une méthode statique</h3>

<h4>Implémentation</h4>

<p>En suivant la logique des classes utilitaires, voici une implémentation possible de ce comportement.</p>

<p>Nous allons créer une classe utilitaire nommée <code>SecurityUtils</code> qui dispose d'une méthode statique <code>sha256</code> qui hash un texte en clair.</p>

<pre><code class="java">public class SecurityUtils {

   public static String sha256(String plainText) {
     try {

        MessageDigest md;
        md = MessageDigest.getInstance("SHA-256");
        md.update(plainText.getBytes("iso-8859-1"), 0, plainText.length());
        byte[] shaHash = md.digest();
        return toHexadecimal(shaHash); 

     } catch (UnsupportedEncodingException | NoSuchAlgorithmException e) {
        logger.error(e);
     } 
   }

}
</code></pre>

<p>Ensuite, la classe du service qui va appeler cette méthode</p>

<pre><code class="java">public class UserService {

   public User save(User user, String plainPassword) {

      user.setPassword(SecurityUtils.sha256(plainPassword));        
      repository.save(user);

      return user;
   }

}
</code></pre>

<p>Ce code semble correct et est très courant dans les programmes Java. Cependant, il me pose un problème conséquent. En effet, comment tester la méthode <code>save</code> de manière unitaire ?</p>

<h4>Tests</h4>

<p>Tester unitairement une méthode qui effectue des appels statiques est compliqué. Un test unitaire compliqué est souvent un symptôme d'un code trop couplé et mal conçu.</p>

<p>Voici une implémentation naïve du test unitaire de la méthode <code>save</code>.</p>

<pre><code class="java">public class UserServiceTest {

   @Test
   public void should_hash_password_when_save() {

      User user = new UserService().save(new User(), "pass_word");

      assertThat(user.getPassword).isEqualTo(SecurityUtils.sha256("pass_word"));
   }
}
</code></pre>

<p>Ce test a le mérite de ne pas dépendre de l'implémentation de <code>sha256</code>. Cependant, si celle-ci lance une exception, ou bien retourne toujours une chaine vide par exemple, le test peut générer des faux négatifs ou des faux positifs sans que l'on sache si cela provient du service ou de la classe utilitaire.</p>

<p>Il est bien évidemment possible de mocker des méthodes statiques avec des librairies comme <a href="https://code.google.com/p/powermock/">PowerMock</a> mais je préfère éviter d'utiliser ce genre de raccourci. C'est pourquoi je préfère me passer de méthodes statiques et utiliser des méthodes d'instances à la place.</p>

<h3>Utilisation d'une méthode d'instance</h3>

<h4>Implémentation</h4>

<p>Pour le même cas d'utilisation, voici l'implémentation que j'utiliserais.</p>

<p>Tout d'abord, je définis une interface qui sera le contrat de ma classe utilitaire.</p>

<pre><code class="java">public interface SecurityProvider {

   public String sha256(String plainText);

}
</code></pre>

<p>Ensuite, il faut implémenter cette interface.</p>

<pre><code class="java">public class SecurityProviderImpl implements SecurityProvider {

   public String sha256(String plainText) {
     try {

        MessageDigest md;
        md = MessageDigest.getInstance("SHA-256");
        md.update(plainText.getBytes("iso-8859-1"), 0, plainText.length());
        byte[] shaHash = md.digest();
        return toHexadecimal(shaHash); 

     } catch (UnsupportedEncodingException | NoSuchAlgorithmException e) {
        logger.error(e);
     } 
   }

}
</code></pre>

<p>Finalement, pour utiliser cette classe, il faut l'injecter dans le service. L'injection peut se faire à la main, via Spring ou JEE mais cela pourrait être l'objet d'un autre article donc je ne rentrerai pas dans les détails.</p>

<pre><code class="java">public class UserService {

   private final SecurityProvider securityProvider;

   public UserService(SecurityProvider securityProvider) {
      this.securityProvider = securityProvider;
   }

   public User save(User user, String plainPassword) {

      user.setPassword(securityProvider.sha256(plainPassword));        
      repository.save(user);

      return user;
   }

}
</code></pre>

<h4>Tests</h4>

<p>Cette implémentation est beaucoup plus simple à tester unitairement. En effet, il suffit de mocker l'interface pour vérifier le bon comportement du service. Ce mock peut être fait manuellement ou à l'aide d'un framework comme <a href="http://mockito.org/">Mockito</a>.</p>

<pre><code class="java">public class UserServiceTest {

   @Test
   public void should_hash_password_when_save() {

      SecurityProvider securityProvider = new SecurityProvider() {

         @Override
         public String sha256(String plainText) {
            return "Hashed :" + plainText;
         }

      }

      User user = new UserService(securityProvider).save(new User(), "pass_word");

      assertThat(user.getPassword).isEqualTo("Hashed :pass_word");
   }
}
</code></pre>

<p>Ce test est à 100% découplé de l'implémentation réelle de la méthode <code>sha256</code> et permet de tester de manière réellement unitaire la méthode <code>save</code> du service.</p>

<h2>Bonnes pratiques et pragmatisme</h2>

<p>L'utilisation des classes utilitaires et des méthodes statiques est globalement à proscrire car cela rend le code fortement couplé et difficile à tester. Cependant, un développeur se doit d'être pragmatique.
En effet, créer une interface, une implémentation et une injection pour chaque appel à une méthode utilitaire peut sembler un peu trop long et verbeux.</p>

<p>Je pense qu'il s'agit de trouver le bon compromis entre une utilisation sage des méthodes statiques et les bonnes pratiques de programmation. Par exemple, il n'est pas utile de mettre en place ce pattern pour des calculs simples comme une valeur absolue, un test sur la présence ou non d'élément dans une liste ou le calcul d'un minimum entre deux nombres. Par contre, quand il s'agit de traitements plus lourds comme des calculs complexes ou la manipulation d'un fichier, ce travail supplémentaire peut porter ses fruits et doit être mis en place.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Distribuer Son Application Java Sur Mac OSX Grâce à Maven]]></title>
    <link href="https://rnowif.github.io/blog/2015/03/20/distribuer-son-application-java-sur-mac-osx-grace-a-maven/"/>
    <updated>2015-03-20T21:21:43+01:00</updated>
    <id>https://rnowif.github.io/blog/2015/03/20/distribuer-son-application-java-sur-mac-osx-grace-a-maven</id>
    <content type="html"><![CDATA[<p>Dans un article précédent, nous avons vu comment distribuer son application Java sur Windows grâce à Maven. Cet article vise à faire la même chose sur MacOSX.
Nous n'allons donc pas revenir sur l'alternative qui vise à distribuer directement le jar et passer directement à la partie qui nous intéresse, à savoir distribuer un exécutable Mac OSX.</p>

<!-- more -->


<h2>Distribuer son application sur Mac OSX</h2>

<p>Sous Mac OSX, l'installation d'une application se fait via un fichier dmg. Le plugin <a href="http://mojo.codehaus.org/osxappbundle-maven-plugin/">osxappbundle</a> permet de générer automatiquement ce fichier.</p>

<h3>Générer le fichier dmg sous Mac</h3>

<p>L'utilisation de ce plugin est cependant différente selon qu'il est exécuté sous Mac ou sous un autre OS. En effet, le fichier dmg ne peut être généré <em>que sous Mac</em>.</p>

<pre><code class="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
  &lt;artifactId&gt;osxappbundle-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0-alpha-1&lt;/version&gt;
  &lt;configuration&gt;
    &lt;bundleName&gt;MyApp&lt;/bundleName&gt;
    &lt;mainClass&gt;com.foo.MyApplication&lt;/mainClass&gt;
    &lt;internetEnable&gt;true&lt;/internetEnable&gt;
    &lt;diskImageFile&gt;${project.build.directory}/MyApp.dmg&lt;/diskImageFile&gt;
  &lt;/configuration&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;phase&gt;package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;bundle&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>

<h3>Générer le fichier app sous Windows ou Linux</h3>

<p>Sous un autre OS, il n'est pas possible de générer le fichier dmg. Le plugin va seulement générer un fichier zip qui, une fois dézippé, va se transformer en application Mac (format app).
Ce fichier app pourra être exécuté en double cliquant dessus simplement.</p>

<p>Pour fonctionner, le plugin a besoin du fichier <code>JavaApplicationStub</code> qui se trouve dans le dossier <code>/System/Library/Frameworks/JavaVM.framework/Resources/MacOS</code> de MacOS. Dans l'exemple ci-dessous, ce fichier a été déposé dans le dossier <code>src/main/resources</code> du projet.</p>

<pre><code class="xml">&lt;plugin&gt;
  &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
  &lt;artifactId&gt;osxappbundle-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.0-alpha-1&lt;/version&gt;
  &lt;configuration&gt;
    &lt;bundleName&gt;MyApp&lt;/bundleName&gt;
    &lt;mainClass&gt;com.foo.MyApplication&lt;/mainClass&gt;
    &lt;internetEnable&gt;true&lt;/internetEnable&gt;
    &lt;javaApplicationStub&gt;${basedir}/src/main/resources/JavaApplicationStub&lt;/javaApplicationStub&gt;
    &lt;buildDirectory&gt;${project.build.directory}/MyApp.app&lt;/buildDirectory&gt;
    &lt;diskImageFile&gt;${project.build.directory}/MyApp.dmg&lt;/diskImageFile&gt;
    &lt;zipFile&gt;${project.build.directory}/MyApp.zip&lt;/zipFile&gt;
  &lt;/configuration&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;phase&gt;package&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;bundle&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;
</code></pre>

<h2>Conclusion</h2>

<p>Générer un fichier exécutable pour MacOS n'est pas très compliqué. Cependant, afin de générer un fichier dmg, il faut absolument que la machine qui utilise le plugin maven tourne sous MacOS. Dans le cas contraire (un serveur d'intégration continue sous Linux par exemple), il faudra se contenter d'un fichier zip qui, une fois dézippé, pourra être ouvert comme une application normale.</p>
]]></content>
  </entry>
  
</feed>
